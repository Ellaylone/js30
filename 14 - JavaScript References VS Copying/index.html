<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>JS Reference VS Copy</title>
    </head>
    <body>

        <script>
         // start with strings, numbers and booleans
         let age = 100,
             age2 = age;

         console.log(age, age2);

         age = 200;
         console.log(age, age2);

         let name = 'Wes',
             name2 = name;

         console.log(name, name2);

         name = 'Wesley';
         console.log(name, name2);

         // Let's say we have an array
         const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

         // and we want to make a copy of it.
         const team = players;
         console.log(players, team);

         team[3] = 'Lux';
         console.log(players, team);

         const team2 = players.slice();

         team2[3] = 'Poppy';
         console.log(players, team2)

         // one day

         // or create a new array and concat the old one in

         // or use the new ES6 Spread
         const team3 = [...players];

         team3[3] = 'Spread';
         console.log(players, team3);

         // now when we update it, the original one isn't changed

         // The same thing goes for objects, let's say we have a person object
         const person = {
             name: 'Wes Bos',
             age: 80
         };

         // with Objects

         // and think we make a copy:
         const wesbos = person
         wesbos.number = 90;

         console.log(person, wesbos);

         // how do we take a copy instead?

         // We will hopefully soon see the object ...spread
         const cap = Object.assign({}, person, { number: 100 });
         console.log(person, cap);

         // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.

        </script>

    </body>
</html>
